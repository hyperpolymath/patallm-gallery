-- |
-- Module      : ClaudeVerify.Internal.SMTLIB
-- Description : SMT-LIB v2 generation from AST
-- Copyright   : (c) Hyperpolymath, 2025
-- License     : MIT
--
-- Generates SMT-LIB v2 format formulas from the internal AST.
-- This is the primary format for communicating with Z3, CVC5, Yices2, etc.

module ClaudeVerify.Internal.SMTLIB
    ( -- * Generation
      toSMTLIB
    , exprToSMT
    , typeToSMT

      -- * Builders
    , SMTBuilder
    , runSMTBuilder
    , declareConst
    , declareSort
    , assertFormula
    , checkSat
    , getModel
    ) where

import ClaudeVerify.Internal.AST
import ClaudeVerify.Internal.Types (VCFormula(..), FormulaFormat(..))

import Control.Monad.State.Strict
import Data.Text (Text)
import qualified Data.Text as T
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map

-- | State for SMT-LIB generation
data SMTState = SMTState
    { smtDeclarations :: [Text]
    , smtAssertions   :: [Text]
    , smtVarCounter   :: Int
    , smtTypeMap      :: Map Text Text  -- ^ Map from source types to SMT sorts
    } deriving stock (Eq, Show)

-- | SMT builder monad
type SMTBuilder a = State SMTState a

-- | Initial state
initialState :: SMTState
initialState = SMTState
    { smtDeclarations = []
    , smtAssertions   = []
    , smtVarCounter   = 0
    , smtTypeMap      = Map.fromList
        [ ("i32", "Int")
        , ("i64", "Int")
        , ("u32", "Int")
        , ("u64", "Int")
        , ("isize", "Int")
        , ("usize", "Int")
        , ("f32", "Real")
        , ("f64", "Real")
        , ("bool", "Bool")
        , ("Int", "Int")
        , ("Integer", "Int")
        , ("Bool", "Bool")
        , ("Double", "Real")
        , ("Float", "Real")
        ]
    }

-- | Run the SMT builder and get the result
runSMTBuilder :: SMTBuilder a -> (a, Text)
runSMTBuilder builder =
    let (result, finalState) = runState builder initialState
        header = "; Generated by claude-verify\n; SMT-LIB v2.6\n\n"
        logic = "(set-logic ALL)\n\n"
        decls = T.unlines (reverse $ smtDeclarations finalState)
        asserts = T.unlines (reverse $ smtAssertions finalState)
        footer = "\n(check-sat)\n(get-model)\n"
    in (result, header <> logic <> decls <> asserts <> footer)

-- | Fresh variable name
freshVar :: Text -> SMTBuilder Text
freshVar prefix = do
    counter <- gets smtVarCounter
    modify' $ \s -> s { smtVarCounter = counter + 1 }
    pure $ prefix <> "_" <> T.pack (show counter)

-- | Declare a constant
declareConst :: Text -> Text -> SMTBuilder ()
declareConst name sort = do
    let decl = "(declare-const " <> name <> " " <> sort <> ")"
    modify' $ \s -> s { smtDeclarations = decl : smtDeclarations s }

-- | Declare a sort
declareSort :: Text -> Int -> SMTBuilder ()
declareSort name arity = do
    let decl = "(declare-sort " <> name <> " " <> T.pack (show arity) <> ")"
    modify' $ \s -> s { smtDeclarations = decl : smtDeclarations s }

-- | Assert a formula
assertFormula :: Text -> SMTBuilder ()
assertFormula formula = do
    let assertion = "(assert " <> formula <> ")"
    modify' $ \s -> s { smtAssertions = assertion : smtAssertions s }

-- | Add check-sat (usually added automatically)
checkSat :: SMTBuilder ()
checkSat = pure ()  -- Handled in runSMTBuilder

-- | Add get-model (usually added automatically)
getModel :: SMTBuilder ()
getModel = pure ()  -- Handled in runSMTBuilder

-- | Convert an expression to SMT-LIB format
exprToSMT :: Expression -> SMTBuilder Text
exprToSMT expr = case expr of
    ExprLit _ lit -> pure $ literalToSMT lit

    ExprVar _ qident -> pure $ qualIdentToSMT qident

    ExprBinOp _ op e1 e2 -> do
        s1 <- exprToSMT e1
        s2 <- exprToSMT e2
        pure $ "(" <> binOpToSMT op <> " " <> s1 <> " " <> s2 <> ")"

    ExprUnOp _ op e -> do
        s <- exprToSMT e
        pure $ "(" <> unOpToSMT op <> " " <> s <> ")"

    ExprIf _ cond thenE elseE -> do
        sCond <- exprToSMT cond
        sThen <- exprToSMT thenE
        case elseE of
            Just e -> do
                sElse <- exprToSMT e
                pure $ "(ite " <> sCond <> " " <> sThen <> " " <> sElse <> ")"
            Nothing ->
                -- If without else becomes implication
                pure $ "(=> " <> sCond <> " " <> sThen <> ")"

    ExprCall _ fn args -> do
        sFn <- exprToSMT fn
        sArgs <- mapM exprToSMT args
        pure $ "(" <> sFn <> " " <> T.intercalate " " sArgs <> ")"

    ExprIndex _ arr idx -> do
        sArr <- exprToSMT arr
        sIdx <- exprToSMT idx
        pure $ "(select " <> sArr <> " " <> sIdx <> ")"

    ExprTuple _ exprs -> do
        sExprs <- mapM exprToSMT exprs
        -- Represent as tuple sort application
        pure $ "(mkTuple " <> T.intercalate " " sExprs <> ")"

    ExprLambda _ params body -> do
        -- Named lambda for let-like constructs
        sBody <- exprToSMT body
        let paramNames = [ identToSMT ident | (PatIdent ident, _) <- params ]
        if null paramNames
            then pure sBody
            else do
                -- Use let binding
                pure $ "(let (" <> T.intercalate " " paramNames <> ") " <> sBody <> ")"

    ExprAssert _ e _ -> exprToSMT e
    ExprAssume _ e -> exprToSMT e
    ExprInvariant _ e -> exprToSMT e
    ExprRequires _ e -> exprToSMT e
    ExprEnsures _ e -> exprToSMT e

    -- Block: sequence of statements, return last expression value
    ExprBlock _ stmts -> stmtsToSMT stmts

    -- For unhandled cases, emit a comment
    _ -> do
        v <- freshVar "unknown"
        declareConst v "Int"  -- Default to Int
        pure v

-- | Convert statements to SMT (focusing on the result value)
stmtsToSMT :: [Statement] -> SMTBuilder Text
stmtsToSMT [] = pure "true"
stmtsToSMT [StmtExpr _ e] = exprToSMT e
stmtsToSMT (StmtLet _ (PatIdent ident) _ e : rest) = do
    sE <- exprToSMT e
    sRest <- stmtsToSMT rest
    pure $ "(let ((" <> identToSMT ident <> " " <> sE <> ")) " <> sRest <> ")"
stmtsToSMT (_ : rest) = stmtsToSMT rest

-- | Convert a literal to SMT
literalToSMT :: Literal -> Text
literalToSMT = \case
    LitInt n -> T.pack (show n)
    LitFloat f -> T.pack (show f)
    LitBool True -> "true"
    LitBool False -> "false"
    LitChar c -> T.pack (show $ fromEnum c)  -- Char as Int
    LitString s -> "\"" <> s <> "\""
    LitUnit -> "true"  -- Unit as true

-- | Convert binary operator
binOpToSMT :: BinOp -> Text
binOpToSMT = \case
    Add -> "+"
    Sub -> "-"
    Mul -> "*"
    Div -> "div"
    Mod -> "mod"
    And -> "and"
    Or -> "or"
    Xor -> "xor"
    Eq -> "="
    Ne -> "distinct"
    Lt -> "<"
    Le -> "<="
    Gt -> ">"
    Ge -> ">="
    Shl -> "bvshl"
    Shr -> "bvashr"
    BitAnd -> "bvand"
    BitOr -> "bvor"
    BitXor -> "bvxor"

-- | Convert unary operator
unOpToSMT :: UnOp -> Text
unOpToSMT = \case
    Neg -> "-"
    Not -> "not"
    BitNot -> "bvnot"
    Deref -> ""  -- Dereference becomes identity in pure logic
    Ref -> ""    -- Reference becomes identity

-- | Convert identifier
identToSMT :: Ident -> Text
identToSMT (Ident name) = sanitizeIdent name

-- | Convert qualified identifier
qualIdentToSMT :: QualifiedIdent -> Text
qualIdentToSMT (QualifiedIdent mods name) =
    sanitizeIdent $ T.intercalate "_" (mods ++ [name])

-- | Sanitize identifier for SMT-LIB
sanitizeIdent :: Text -> Text
sanitizeIdent t =
    let sanitized = T.concatMap sanitizeChar t
    in if T.null sanitized || isReserved sanitized
       then "_" <> sanitized
       else sanitized
  where
    sanitizeChar c
        | c `elem` ['a'..'z'] = T.singleton c
        | c `elem` ['A'..'Z'] = T.singleton c
        | c `elem` ['0'..'9'] = T.singleton c
        | c == '_' = T.singleton c
        | otherwise = T.pack $ "_" <> show (fromEnum c) <> "_"

    isReserved w = w `elem`
        [ "let", "and", "or", "not", "true", "false"
        , "Int", "Bool", "Real", "String", "Array"
        , "assert", "check-sat", "declare-const", "define-fun"
        ]

-- | Convert a type to SMT sort
typeToSMT :: Type -> SMTBuilder Text
typeToSMT ty = case ty of
    TyName qident -> do
        typeMap <- gets smtTypeMap
        let name = qualIdentToSMT qident
        pure $ Map.findWithDefault name name typeMap

    TyApp base args -> do
        sBase <- typeToSMT base
        sArgs <- mapM typeToSMT args
        pure $ "(" <> sBase <> " " <> T.intercalate " " sArgs <> ")"

    TyFun argTys retTy -> do
        sArgs <- mapM typeToSMT argTys
        sRet <- typeToSMT retTy
        pure $ "(Array " <> T.intercalate " " sArgs <> " " <> sRet <> ")"

    TyRef t -> typeToSMT t  -- References become the underlying type
    TyMutRef t -> typeToSMT t

    TyArray elemTy _size -> do
        sElem <- typeToSMT elemTy
        pure $ "(Array Int " <> sElem <> ")"

    TyTuple tys -> do
        sTys <- mapM typeToSMT tys
        pure $ "(Tuple " <> T.intercalate " " sTys <> ")"

    TyUnit -> pure "Bool"  -- Unit represented as Bool
    TyInfer -> pure "Int"  -- Default inference to Int

-- | Convert a full expression to VCFormula
toSMTLIB :: Expression -> VCFormula
toSMTLIB expr =
    let (_, smt) = runSMTBuilder $ do
            formula <- exprToSMT expr
            assertFormula formula
    in VCFormula SMTLIB2 smt
